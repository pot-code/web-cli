{% func GoBackendBootstrapCreate(projectName string, author string) -%}
package bootstrap

import (
	"context"
	"log"
	"strings"

	"github.com/labstack/echo/v4"
	echo_middleware "github.com/labstack/echo/v4/middleware"
	gobit "github.com/pot-code/gobit/pkg"
	"github.com/pot-code/gobit/pkg/db"
	"github.com/pot-code/gobit/pkg/logging"
	"github.com/pot-code/gobit/pkg/middleware"
	"github.com/pot-code/gobit/pkg/util"
	"go.uber.org/zap"
	"golang.org/x/text/language""
)

func NewLogger(cfg *AppConfig, em *util.ExitManager) *zap.Logger {
	logger, err := logging.NewLogger(&logging.LoggerConfig{
		FilePath: cfg.Logging.FilePath,
		Level:    cfg.Logging.Level,
	})
	if err != nil {
		log.Fatalf("failed to create logger: %s", err)
	}

	em.Register(func(ctx context.Context) {
		logger.Sync()
	})

	return logger
}

func NewDB(cfg *AppConfig, logger *zap.Logger, em *util.ExitManager) *db.SqlxDB {
	conn, err := db.NewSqlxDB(&db.SqlDBConfig{
		Driver:  cfg.Database.Driver,
		MaxConn: cfg.Database.MaxConn,
		Dsn:     cfg.Database.Dsn,
		Debug:   cfg.Env == gobit.EnvDevelop,
	}, logger)
	if err != nil {
		log.Fatalf("failed to create DB connection: %s", err)
	}

	em.Register(func(ctx context.Context) {
		conn.Close(ctx)
	})

	logger.Debug("connect to database", zap.String("db.driver", cfg.Database.Driver),
		zap.String("db.dsn", cfg.Database.Dsn),
	)
	return conn
}

// NewEchoServer create http server
func NewEchoServer(cfg *AppConfig, logger *zap.Logger, em *util.ExitManager) *echo.Echo {
	app := echo.New()

	if cfg.Env == gobit.EnvDevelop {
		app.Use(middleware.Logging(logger, middleware.LoggingConfig{
			Skipper: func(e echo.Context) bool {
				return strings.HasPrefix(e.Request().RequestURI, "/healthz")
			},
		}))
	}

	app.Use(
		middleware.ErrorHandling(logger, middleware.ErrorHandlingOption{StackDepth: 3}),
		echo_middleware.Secure(),
		echo_middleware.RequestID(),
		middleware.ParseAcceptLanguage([]language.Tag{
			language.English,
			language.Chinese,
		}),
	)

	em.Register(func(ctx context.Context) {
		app.Close()
	})

	return app
}
{% endfunc %}


{% func GoBackendBootstrapConfig(projectName string) -%}
package bootstrap

import (
	"runtime"

	gobit "github.com/pot-code/gobit/pkg"
	"github.com/spf13/pflag"
)

// AppConfig App option object
type AppConfig struct {
	AppID    string `mapstructure:"app_id" yaml:"app_id" validate:"required"`           // Application ID
	Host     string `mapstructure:"host" yaml:"host"`                                   // bind host address
	Port     int    `mapstructure:"port" yaml:"port"`                                   // bind listen port
	Env      string `mapstructure:"env" yaml:"env" validate:"oneof=develop production"` // runtime environment
	Database struct {
		Driver  string `mapstructure:"driver" yaml:"driver" validate:"required"` // driver name
		Dsn     string `mapstructure:"dsn" yaml:"dsn" validate:"required"`       // dsn string
		MaxConn int32  `mapstructure:"maxconn" yaml:"maxconn" validate:"min=1"`  // maximum opening connections number
	} `mapstructure:"database" yaml:"database"`
	Logging struct {
		FilePath string `mapstructure:"file_path" yaml:"file_path"`                                // log file path
		Level    string `mapstructure:"level" yaml:"level" validate:"oneof=debug info warn error"` // global logging level
	} `mapstructure:"logging" yaml:"logging"`
}

func init() {
	// common
	pflag.String("host", "", "binding address")
	pflag.String("app_id", "{%s projectName %}", "application identifier (required)")
	pflag.String("env", gobit.EnvDevelop, "runtime environment, can be 'develop' or 'production'")
	pflag.Int("port", 8081, "listening port")

	// database
	pflag.String("database.driver", "pgx", "database driver to use")
	pflag.String("database.dsn", "", "database host")
	pflag.Int32("database.maxconn", int32(runtime.NumCPU()), `max connection count, if you encounter a "too many connections" error, please consider
	increasing the max_connection value of your db server, or lower this value`)

	// logging
	pflag.String("logging.level", "info", "logging level")
	pflag.String("logging.file_path", "", "log to file")
}
{% endfunc %}

{% func GoBackendCmdWeb(projectName string, author string) -%}
package cmd

import (
	"fmt"
	"log"
	"time"

	"github.com/{%s author %}/{%s projectName %}/bootstrap"
	"github.com/{%s author %}/{%s projectName %}/controller"
	"github.com/pot-code/gobit/pkg/api"
	"github.com/pot-code/gobit/pkg/util"
)

func Serve(ep string) {
	cfg := new(bootstrap.AppConfig)
	if err := util.LoadConfig(ep, cfg); err != nil {
		log.Fatal(err)
	}

	em := util.NewExitManager()
	logger := bootstrap.NewLogger(cfg, em)
	server := bootstrap.NewEchoServer(cfg, logger, em)

	controller.RegisterRoutes(server, cfg)
	api.PrintRoutes(server, logger)

	go func() {
		if err := server.Start(fmt.Sprintf("%s:%d", cfg.Host, cfg.Port)); err != nil {
			log.Fatal(err)
		}
	}()

	em.Wait(30 * time.Second)
}
{% endfunc %}

{% func GoBackendMain(projectName string, author string) -%}
package main

import "github.com/{%s author %}/{%s projectName %}/cmd"

// EnvPrefix env prefix for viper, injected by build flags
var EnvPrefix string

func main() {
	cmd.Serve(EnvPrefix)
}
{% endfunc %}

{% func GoBackendMod(projectName string, author string, version string) -%}
module github.com/{%s author %}/{%s projectName %}

go {%s version %}

require (
)
{% endfunc %}

{% func GoBackendController() -%}
package controller

import (
	"github.com/labstack/echo/v4"
	"github.com/pot-code/gobit/pkg/api"
)

func RegisterRoutes(app *echo.Echo) {
	api.CreateEndpoint(app,
		&api.Endpoint{
			Prefix: "api",
			Groups: []*api.ApiGroup{},
		})
}
{% endfunc %}