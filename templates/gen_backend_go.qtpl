{% func GoBackendBootstrapCreate(projectName string, author string) -%}
package bootstrap

import (
	"context"
	"log"
	"net/http"
	"os"
	"strings"

	_ "github.com/jackc/pgx/v4/stdlib"
	"github.com/jmoiron/sqlx"
	"github.com/labstack/echo/v4"
	echo_middleware "github.com/labstack/echo/v4/middleware"
	gobit "github.com/pot-code/gobit/pkg"
	"github.com/pot-code/gobit/pkg/api"
	"github.com/pot-code/gobit/pkg/logging"
	"github.com/pot-code/gobit/pkg/middleware"
	"github.com/pot-code/gobit/pkg/util"
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
)

func NewLogger(cfg *AppConfig, em *util.ExitManager) *zap.Logger {
	ec := logging.NewEcsConfig()
	enabler, err := logging.GetLevelEnabler(cfg.Logging.Level)
	if err != nil {
		log.Fatalf("failed to create logger: %s", err)
	}

	var (
		out zapcore.WriteSyncer
		zc  zapcore.Encoder
	)
	if cfg.Logging.Format == "json" {
		zc = zapcore.NewJSONEncoder(ec)
	} else {
		zc = zapcore.NewConsoleEncoder(ec)
	}

	p := cfg.Logging.FilePath
	if p == "" {
		out = os.Stderr
	} else {
		out, err = logging.NewFileSyncer(p)
		if err != nil {
			log.Fatalf("failed to create logger: %s", err)
		}
	}

	core := zapcore.NewCore(zc, out, enabler)
	logger := zap.New(core)

	em.Register(func(ctx context.Context) {
		logger.Sync()
	})

	return logger
}

func NewSqlxDB(cfg *AppConfig, logger *zap.Logger, em *util.ExitManager) *sqlx.DB {
	conn, err := sqlx.Connect(cfg.Database.Driver, cfg.Database.Dsn)
	if err != nil {
		log.Fatalf("failed to create DB connection: %s", err)
	}

	conn.DB.SetMaxOpenConns(int(cfg.Database.MaxConn))
	conn.DB.SetMaxIdleConns(int(cfg.Database.MaxConn) >> 2)
	em.Register(func(ctx context.Context) {
		conn.Close()
	})

	logger.Debug("connect to database",
		zap.String("db.driver", cfg.Database.Driver),
		zap.String("db.dsn", cfg.Database.Dsn),
		zap.Int32("db.maxconn", cfg.Database.MaxConn),
	)
	return conn
}

// NewEchoServer create http server
func NewEchoServer(cfg *AppConfig, logger *zap.Logger, em *util.ExitManager) *echo.Echo {
	app := echo.New()

	if cfg.Env == gobit.EnvDevelop {
		app.Use(middleware.Logging(middleware.LoggingConfig{
			Skipper: func(e echo.Context) bool {
				return strings.HasPrefix(e.Request().RequestURI, "/healthz")
			},
			LogFn: func(c echo.Context) {
				code := c.Response().Status
				rid := c.Response().Header().Get(echo.HeaderXRequestID)
				logger.Debug(
					http.StatusText(code),
					zap.String("trace.id", rid),
					zap.String("url.original", c.Path()),
					zap.String("http.request.referrer", c.Request().Referer()),
					zap.String("http.request.method", c.Request().Method),
					zap.Strings("route.params.name", c.ParamNames()),
					zap.Strings("route.params.value", c.ParamValues()),
					zap.Int("http.request.status_code", code),
				)
			},
		}))
	}

	app.Use(
		middleware.ErrorHandling(middleware.ErrorHandlingOption{Handler: func(c echo.Context, err error) {
			traceID := c.Response().Header().Get(echo.HeaderXRequestID)
			msg := api.ErrInternalError.Error()
			logger.Error(err.Error(), zap.String("trace.id", traceID), zap.Object("detail", logging.NewZapErrorWrapper(err, 3)))

			c.JSON(http.StatusInternalServerError,
				api.NewRESTStandardError(msg).SetTraceID(traceID),
			)
		}}),
		echo_middleware.Secure(),
		echo_middleware.RequestID(),
		middleware.ParseAcceptLanguage(middleware.ParseAcceptLanguageOption{}),
	)

	em.Register(func(ctx context.Context) {
		app.Close()
	})

	return app
}
{% endfunc %}


{% func GoBackendBootstrapConfig(projectName string) -%}
package bootstrap

import (
	"runtime"

	gobit "github.com/pot-code/gobit/pkg"
	"github.com/spf13/pflag"
)

// AppConfig App configuration
type AppConfig struct {
	AppID    string `mapstructure:"app_id" yaml:"app_id" validate:"required"`           // Application ID
	Port     string `mapstructure:"port" yaml:"port"`                                   // bind listen port
	Env      string `mapstructure:"env" yaml:"env" validate:"oneof=develop production"` // runtime environment
	Database struct {
		Driver  string `mapstructure:"driver" yaml:"driver" validate:"required"` // driver name
		Dsn     string `mapstructure:"dsn" yaml:"dsn" validate:"required"`       // dsn string
		MaxConn int32  `mapstructure:"maxconn" yaml:"maxconn" validate:"min=1"`  // maximum opening connections number
	} `mapstructure:"database" yaml:"database"`
	Logging struct {
		FilePath string `mapstructure:"file_path" yaml:"file_path"` // log file path
		Level    string `mapstructure:"level" yaml:"level"`         // global logging level
		Format   string `mapstructure:"format" yaml:"format" validate:"oneof=json console"`
	} `mapstructure:"logging" yaml:"logging"`
}

func init() {
	// common
	pflag.String("app_id", "{%v projectName %}", "application identifier (required)")
	pflag.String("env", gobit.EnvDevelop, "runtime environment, can be 'develop' or 'production'")
	pflag.String("port", ":8081", "listening port")

	// database
	pflag.String("database.driver", "pgx", "database driver to use")
	pflag.String("database.dsn", "", "database host")
	pflag.Int32("database.maxconn", int32(runtime.NumCPU()), `max connection count, if you encounter a "too many connections" error, please consider
	increasing the max_connection value of your db server, or lower this value`)

	// logging
	pflag.String("logging.level", "info", "logging level")
	pflag.String("logging.file_path", "", "log to file")
	pflag.String("logging.format", "console", "log format, should be json or console")
}
{% endfunc %}

{% func GoBackendCmdWeb(projectName string, author string) -%}
package cmd

import (
	"errors"
	"log"
	"net/http"
	"time"

	"github.com/{%s author %}/{%s projectName %}/bootstrap"
	"github.com/{%s author %}/{%s projectName %}/server"
	"github.com/pot-code/gobit/pkg/api"
	"github.com/pot-code/gobit/pkg/util"
	"github.com/pot-code/gobit/pkg/validate"
)

func Serve() {
	cfg := new(bootstrap.AppConfig)
	cm := util.NewConfigManager()
	v := validate.NewValidator()

	if err := cm.LoadConfig(cfg); err != nil {
		log.Fatalf("failed to load config: %s", err)
	}
	if err := v.Struct(cfg, "en"); err != nil {
		log.Fatalf("failed to validate config: \n%s", err)
	}

	em := util.NewExitManager()
	defer em.WaitSignal(30 * time.Second)

	hs := server.InitializeServer(cfg, em)

	server.RegisterRoutes(cfg, hs)
	api.PrintRoutes(hs.Server, hs.Logger)

	go func() {
		if err := hs.Server.Start(cfg.Port); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				log.Fatal(err)
			}
		}
	}()
}
{% endfunc %}

{% func GoBackendMain(projectName string, author string) -%}
package main

import "github.com/{%s author %}/{%s projectName %}/cmd"

func main() {
	cmd.Serve()
}
{% endfunc %}

{% func GoBackendMod(projectName string, author string, version string) -%}
module github.com/{%s author %}/{%s projectName %}

go {%s version %}

require (
)
{% endfunc %}

{% func GoBackendServerRoutes(projectName string, author string) -%}
package server

import (
	"github.com/{%s author %}/{%s projectName %}/bootstrap"
	"github.com/pot-code/gobit/pkg/api"
)

func RegisterRoutes(cfg *bootstrap.AppConfig, hs *HttpServer) {
	api.CreateEndpoint(hs.Server,
		&api.Endpoint{
			Prefix: "api",
			Groups: []*api.ApiGroup{},
		})
}
{% endfunc %}

{% func GoBackendServerServer() -%}
package server

import (
	"github.com/labstack/echo/v4"
	"go.uber.org/zap"
)

type Handler struct {
}

func NewHandler() *Handler {
	return &Handler{}
}

type HttpServer struct {
	Logger    *zap.Logger
	Server    *echo.Echo
	Handlers  *Handler
}

func NewHttpServer(logger *zap.Logger, server *echo.Echo, handler *Handler) *HttpServer {
	return &HttpServer{Logger: logger, Server: server, Handlers: handler}
}
{% endfunc %}

{% func GoBackendServerWire(projectName string, author string) -%}
//+build wireinject

package server

import (
	"github.com/google/wire"
	"github.com/{%s author %}/{%s projectName %}/bootstrap"
	"github.com/pot-code/gobit/pkg/util"
)

func InitializeServer(cfg *bootstrap.AppConfig, em *util.ExitManager) *HttpServer {
	wire.Build(
		NewHttpServer, NewHandler,
		bootstrap.NewEchoServer, bootstrap.NewLogger,
	)
	return &HttpServer{}
}
{% endfunc %}

{% func GoBackendVscodeSettings() -%}
{
	"go.inferGopath": false,
	"gopls": {
		"build.buildFlags": [
			"-tags=wireinject"
		]
	},
}
{% endfunc %}