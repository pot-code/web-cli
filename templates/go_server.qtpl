{% func GoServerConfig() -%}
package config

import (
	"log"

	"github.com/google/wire"
	"github.com/pot-code/gobit/pkg/config"
	"github.com/pot-code/gobit/pkg/logging"
	"github.com/pot-code/gobit/pkg/util"
	"github.com/pot-code/gobit/pkg/validate"
)

type AppConfig struct {
	Port     int                    `mapstructure:"port" yaml:"port"`
	Base     *config.BaseConfig     `mapstructure:"base" yaml:"base"`
	Logging  *logging.LoggingConfig `mapstructure:"logging" yaml:"logging"`
}

func NewAppConfig() *AppConfig {
	cfg := new(AppConfig)
	cm := config.NewConfigManager()
	util.HandleFatalError("failed to load config", cm.LoadConfig(cfg))

	v := validate.NewValidator()
	if err := v.Struct(cfg); err != nil {
		log.Fatalf("failed to validate config: \n%v", err)
	}
	return cfg
}

var ConfigSet = wire.NewSet(
	wire.FieldsOf(new(*AppConfig), "Base", "Logging"),
	NewAppConfig,
)
{% endfunc %}

{% func GoServerWebRouter() -%}
package web

import (
	"github.com/pot-code/gobit/pkg/api"
)

func NewEndpoint(hs *HttpServer) *api.Endpoint {
	return &api.Endpoint{
		Prefix: "api",
		Groups: []*api.ApiGroup{},
	}
}
{% endfunc %}

{% func GoServerWebServer(project, author string) -%}
package web

import (
	"context"
	"log"
	"net/http"
	"time"
	
	"github.com/google/wire"
	"github.com/labstack/echo/v4"
	"github.com/{%s author %}/{%s project %}/config"
	echo_middleware "github.com/labstack/echo/v4/middleware"
	gobit "github.com/pot-code/gobit/pkg"
	"github.com/pot-code/gobit/pkg/api"
	"github.com/pot-code/gobit/pkg/logging"
	"github.com/pot-code/gobit/pkg/middleware"
	"github.com/pot-code/gobit/pkg/util"
	"go.uber.org/zap"
)

type HandlerCollection struct {
}

type HttpServer struct {
	Config    *config.AppConfig
	Logger    *zap.Logger
	Server    *echo.Echo
	Handlers  *HandlerCollection
}

func NewHttpServer(
	cfg *config.AppConfig,
	logger *zap.Logger,
	server *echo.Echo,
	handlers *HandlerCollection,
) *HttpServer {
	return &HttpServer{Config: cfg, Logger: logger, Server: server, Handlers: handlers}
}

// NewEchoServer create http server
func NewEchoServer(cfg *config.AppConfig, logger *zap.Logger, lm *util.LifecycleManager) *echo.Echo {
	app := echo.New()

	if cfg.Base.Env == gobit.EnvProduction {
		app.HideBanner = true
	}

	app.GET("/healthz", func(c echo.Context) error {
		return lm.Probe(5 * time.Second)
	})
	app.Use(
		middleware.ErrorHandling(middleware.ErrorHandlingOption{Handler: func(c echo.Context, err error) {
			msg := api.ErrInternalError.Error()
			logger.Error(msg, zap.Object("error", logging.NewZapStacktraceError(err, 3)))
			c.JSON(http.StatusInternalServerError,
				api.NewRESTStandardError(msg),
			)
		}}),
		echo_middleware.Gzip(),
		echo_middleware.CORS(),
		echo_middleware.Secure(),
		middleware.ParseAcceptLanguage(middleware.ParseAcceptLanguageOption{}),
	)

	lm.OnExit(func(ctx context.Context) {
		log.Println("[echo.Echo] shutdown server")
		app.Close()
	})

	return app
}

var HttpSet = wire.NewSet(
	wire.Struct(new(HandlerCollection), "*"), NewEchoServer,
)
{% endfunc %}

{% func GoServerCmdWebMain(project, author string) -%}
package main

import (
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/{%s author %}/{%s project %}/web"
	"github.com/pot-code/gobit/pkg/api"
	"github.com/pot-code/gobit/pkg/util"
)

func main() {
	lm := util.NewLifecycleManager()
	defer lm.WaitExitSignal(30 * time.Second)

	hs := web.InitHttpServer(lm)
	ep := web.NewEndpoint(hs)
	api.ApplyEndpoint(hs.Server, ep)
	api.PrintRoutes(hs.Server, hs.Logger)

	go func() {
		if err := hs.Server.Start(fmt.Sprintf(":%d", hs.Config.Port)); err != nil {
			if !errors.Is(err, http.ErrServerClosed) {
				log.Fatal(err)
			}
		}
	}()
}
{% endfunc %}

{% func GoServerWebWire(project, author string) -%}
//+build wireinject

package web

import (
	"github.com/google/wire"
	"github.com/{%s author %}/{%s project %}/config"
	"github.com/pot-code/gobit/pkg/util"
	"github.com/pot-code/gobit/pkg/logging"
)

func InitHttpServer(lm *util.LifecycleManager) *HttpServer {
	wire.Build(
		NewHttpServer, HttpSet, config.ConfigSet,
		logging.NewZapLoggerProvider,
	)
	return &HttpServer{}
}
{% endfunc %}

{% func GoServerVscodeSettings() -%}
{
	"go.inferGopath": false,
	"gopls": {
		"build.buildFlags": [
			"-tags=wireinject"
		]
	},
}
{% endfunc %}

{% func GoMod(project string, author string, version string) -%}
module github.com/{%s author %}/{%s project %}

go {%s version %}

require (
)
{% endfunc %}


{% func GoServerConfigYml(project string) -%}
port: 8080
base:
  app_id: {%s project %}
  env: development
logging:
  level: debug
  format: console
{% endfunc %}

{% func GoServerTools() -%}
// +build tools

package tools

import _ "github.com/google/wire/cmd/wire"
{% endfunc %}

{% func GoServerDockerfile() -%}
FROM golang:1.16 as builder

WORKDIR /go/src

COPY go.mod .
COPY go.sum .

RUN go mod download

COPY . .
# build prod app
RUN GOARCH=amd64 GOOS=linux CGO_ENABLED=0 go build -ldflags="-s -w" -o app ./cmd/web

FROM alpine:3.8

WORKDIR /usr/bin/go

COPY --from=builder ["/go/src/app", "./"]

RUN chmod 0755 app

EXPOSE 8081 

CMD [ "./app" ]
{% endfunc %}